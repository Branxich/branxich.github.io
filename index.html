<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Branxi · Perp DEX Referrals</title>
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<style>
/* ─── RESET ─────────────────────────────────────────────────────────── */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
:root {
  --bg: #0a0a0e;
  --cyan: #00eaff;
  --purple: #aa00ff;
  --fade: #0a0a0e;          /* must match bg for fade-out effect */
  --gap: 20px;
  --card-h: 165px;
  --card-w: 220px;
}
html, body {
  height: 100%;
  background: var(--bg);
  color: #fff;
  font-family: 'Syne', sans-serif;
  overflow-x: hidden;
}

/* ─── WEBGL BACKGROUND ───────────────────────────────────────────────── */
#bg-canvas {
  position: fixed;
  inset: 0;
  width: 100%;
  height: 100%;
  z-index: 0;
  pointer-events: none;
}

/* ─── PAGE SHELL ─────────────────────────────────────────────────────── */
.page {
  position: relative;
  z-index: 1;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding-bottom: 80px;
}

/* ─── HEADER ─────────────────────────────────────────────────────────── */
header {
  width: 100%;
  max-width: 1100px;
  padding: 24px 32px 0;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 14px;
}
.made-by {
  font-family: 'DM Mono', monospace;
  font-size: 13px;
  color: rgba(255,255,255,.38);
  letter-spacing: .04em;
  white-space: nowrap;
}
.x-button {
  font-size: 15px;
  border-radius: 12px;
  background: linear-gradient(180deg, rgb(56,56,56) 0%, rgb(36,36,36) 66%, rgb(41,41,41) 100%);
  color: rgb(218,218,218);
  border: none;
  padding: 2px;
  font-weight: 700;
  cursor: pointer;
  position: relative;
  overflow: hidden;
  text-decoration: none;
  display: inline-block;
  font-family: 'Syne', sans-serif;
}
.x-button span {
  border-radius: 10px;
  padding: 0.55em 1.1em;
  text-shadow: 0px 0px 20px #4b4b4b;
  width: 100%;
  display: flex;
  align-items: center;
  gap: 9px;
  color: inherit;
  transition: background-color 0.3s;
  background-color: rgb(29,29,29);
  background-image:
    radial-gradient(at 95% 89%, rgb(15,15,15) 0px, transparent 50%),
    radial-gradient(at 0% 100%, rgb(17,17,17) 0px, transparent 50%),
    radial-gradient(at 0% 0%, rgb(29,29,29) 0px, transparent 50%);
  white-space: nowrap;
}
.x-button:hover span {
  background-color: rgb(26,25,25);
}
.x-button-overlay {
  position: absolute;
  inset: 0;
  pointer-events: none;
  background: repeating-conic-gradient(rgb(48,47,47) 0.0000001%, rgb(51,51,51) 0.000104%) 60% 60% / 600% 600%;
  filter: opacity(10%) contrast(105%);
}
.x-button svg {
  width: 14px;
  height: 14px;
  fill: rgb(218,218,218);
  flex-shrink: 0;
}

/* ─── HERO ───────────────────────────────────────────────────────────── */
.hero {
  text-align: center;
  margin: 32px 0 56px;
  padding: 0 20px;
}

.hero h1 {
  font-size: clamp(36px, 5vw, 68px);
  font-weight: 800;
  letter-spacing: -.02em;
  font-family: 'Space Grotesk', sans-serif;
  background: linear-gradient(135deg,#fff 30%,rgba(255,255,255,.5));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}
.hero p {
  margin-top: 12px;
  font-family: 'DM Mono', monospace;
  font-size: 15px;
  color: rgba(255,255,255,.38);
  letter-spacing: .1em;
  text-transform: uppercase;
}

/* ─── LOGOLOOP WRAPPER ───────────────────────────────────────────────── */
.loop-outer {
  position: relative;
  width: 100%;
  overflow: hidden;
  /* edge fade matching LogoLoop CSS */
  --fade-w: clamp(40px, 8%, 140px);
}
.loop-outer::before,
.loop-outer::after {
  content: '';
  position: absolute;
  top: 0; bottom: 0;
  width: var(--fade-w);
  pointer-events: none;
  z-index: 10;
}
.loop-outer::before {
  left: 0;
  background: linear-gradient(to right, var(--fade) 0%, transparent 100%);
}
.loop-outer::after {
  right: 0;
  background: linear-gradient(to left, var(--fade) 0%, transparent 100%);
}

/* the scrolling track */
.loop-track {
  display: flex;
  align-items: center;
  width: max-content;
  will-change: transform;
  user-select: none;
  padding: 16px 0 24px;  /* vertical breathing room */
}

/* one repeating sequence */
.loop-seq {
  display: flex;
  align-items: center;
  gap: var(--gap);
  padding-right: var(--gap);  /* gap after last item */
}

/* ─── DEX CARD ───────────────────────────────────────────────────────── */
.dex-card {
  position: relative;
  flex: 0 0 auto;
  width: var(--card-w);
  height: var(--card-h);
  background: rgba(255,255,255,.03);
  border: 1px solid rgba(255,255,255,.08);
  border-radius: 18px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 18px;
  backdrop-filter: blur(14px);
  -webkit-backdrop-filter: blur(14px);
  text-decoration: none;
  overflow: hidden;
  transition: border-color .3s, box-shadow .3s, transform .3s;
  cursor: pointer;
}

/* gradient border glow on hover */
.dex-card::before {
  content: '';
  position: absolute;
  inset: -1px;
  border-radius: 18px;
  background: linear-gradient(135deg, var(--cyan), var(--purple));
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
  padding: 1px;
  opacity: 0;
  transition: opacity .3s;
}

/* subtle inner top glow */
.dex-card::after {
  content: '';
  position: absolute;
  inset: 0;
  border-radius: 18px;
  background: radial-gradient(ellipse 70% 50% at 50% 0%, rgba(0,234,255,.07), transparent 70%);
  pointer-events: none;
}

.dex-card:hover {
  border-color: transparent;
  box-shadow:
    0 0 0 1px rgba(0,234,255,.45),
    0 0 30px rgba(0,234,255,.1),
    0 8px 32px rgba(0,0,0,.5);
  transform: translateY(-4px);
}
.dex-card:hover::before { opacity: 1; }

/* "coming soon" dim */
.dex-card.soon {
  opacity: .5;
  cursor: default;
  pointer-events: none;
}

.card-logo {
  width: 72px;
  height: 72px;
  object-fit: contain;
  border-radius: 10px;
  position: relative;
  z-index: 1;
  flex-shrink: 0;
}
.card-name {
  font-size: 13px;
  font-weight: 700;
  color: rgba(255,255,255,.75);
  letter-spacing: .06em;
  text-transform: uppercase;
  position: relative;
  z-index: 1;
  text-align: center;
  font-family: 'DM Mono', monospace;
}



.card-badge {
  font-family: 'DM Mono', monospace;
  font-size: 10px;
  letter-spacing: .08em;
  color: rgba(255,255,255,.3);
  text-transform: uppercase;
  position: relative;
  z-index: 1;
}

/* ─── FOOTER ─────────────────────────────────────────────────────────── */
/* ─── POSTS CAROUSEL (marquee-style) ─────────────────────────────── */
.posts-loop-outer {
  position: relative;
  width: 100%;
  overflow: hidden;
  overflow-clip-margin: 0;
  padding-bottom: 20px;
  margin-bottom: -20px;
  --fade-w: clamp(40px, 8%, 140px);
}
.posts-loop-outer::before,
.posts-loop-outer::after {
  content: '';
  position: absolute;
  top: 0; bottom: 0;
  width: var(--fade-w);
  pointer-events: none;
  z-index: 10;
}
.posts-loop-outer::before {
  left: 0;
  background: linear-gradient(to right, var(--fade) 0%, transparent 100%);
}
.posts-loop-outer::after {
  right: 0;
  background: linear-gradient(to left, var(--fade) 0%, transparent 100%);
}
.posts-loop-track {
  display: flex;
  align-items: flex-start;
  width: max-content;
  will-change: transform;
  user-select: none;
  padding: 16px 0 24px;
  gap: 24px;
}
.post-card {
  flex: 0 0 auto;
  display: block;
  position: relative;
  border-radius: 18px;
  overflow: hidden;
  border: 1px solid rgba(255,255,255,.08);
  background: rgba(255,255,255,.03);
  text-decoration: none;
  transition: border-color .3s, box-shadow .3s, transform .3s;
  cursor: pointer;
  width: 380px;
}
.post-card::before {
  content: '';
  position: absolute;
  inset: -1px;
  border-radius: 18px;
  background: linear-gradient(135deg, var(--cyan), var(--purple));
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
  padding: 1px;
  opacity: 0;
  transition: opacity .3s;
  pointer-events: none;
}
.post-card:hover {
  border-color: transparent;
  box-shadow: 0 0 0 1px rgba(0,234,255,.45), 0 0 30px rgba(0,234,255,.1), 0 8px 32px rgba(0,0,0,.5);
  transform: translateY(-4px);
}
.post-card:hover::before { opacity: 1; }
.post-card img {
  width: 100%;
  height: auto;
  display: block;
  border-radius: 18px;
}

/* ─── TWEETS SECTION ─────────────────────────────────────────────────── */
.tweets-section {
  width: 100%;
  max-width: 1400px;
  margin: 72px 32px 0;
  padding: 0 32px;
}
.tweets-title {
  text-align: center;
  font-family: 'DM Mono', monospace;
  font-size: 12px;
  color: rgba(255,255,255,.35);
  letter-spacing: .12em;
  text-transform: uppercase;
  margin-bottom: 28px;
}
.tweets-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 18px;
}
.tweet-card {
  position: relative;
  background: rgba(255,255,255,.03);
  border: 1px solid rgba(255,255,255,.08);
  border-radius: 18px;
  overflow: hidden;
  backdrop-filter: blur(14px);
  -webkit-backdrop-filter: blur(14px);
  transition: border-color .3s, box-shadow .3s, transform .3s;
  min-height: 200px;
  display: flex;
  align-items: stretch;
}
.tweet-card::before {
  content: '';
  position: absolute;
  inset: -1px;
  border-radius: 18px;
  background: linear-gradient(135deg, var(--cyan), var(--purple));
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
  padding: 1px;
  opacity: 0;
  transition: opacity .3s;
  pointer-events: none;
}
.tweet-card:hover {
  border-color: transparent;
  box-shadow: 0 0 0 1px rgba(0,234,255,.4), 0 0 30px rgba(0,234,255,.08), 0 8px 32px rgba(0,0,0,.5);
  transform: translateY(-3px);
}
.tweet-card:hover::before { opacity: 1; }
.tweet-card .twitter-widget-wrap {
  width: 100%;
  display: flex;
  align-items: stretch;
}
/* Override Twitter embed iframe to fill card */
.tweet-card twitterwidget,
.tweet-card .twitter-tweet-rendered {
  width: 100% !important;
  margin: 0 !important;
}
@media(max-width:640px){
  .tweets-grid { grid-template-columns: 1fr; }
}

footer {
  margin-top: 72px;
  font-family: 'DM Mono', monospace;
  font-size: 11px;
  color: rgba(255,255,255,.14);
  letter-spacing: .08em;
  text-transform: uppercase;
  text-align: center;
}

/* reduced motion */
@media (prefers-reduced-motion: reduce) {
  .loop-track { transform: none !important; }
}
</style>
</head>
<body>

<!-- PixelBlast-faithful WebGL background -->
<canvas id="bg-canvas"></canvas>

<div class="page">
  <header>
    <span class="made-by">Made by</span>
    <a href="https://x.com/OG_Branxi" target="_blank" rel="noopener" class="x-button">
      <span>
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
          <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-4.714-6.231-5.401 6.231H2.744l7.737-8.835L1.254 2.25H8.08l4.253 5.622zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
        </svg>
        Branxi
      </span>
      <div class="x-button-overlay"></div>
    </a>
  </header>

  <section class="hero">
    <h1>Perp DEX List</h1>
    <p>Currently Trading On</p>
  </section>

  <!-- LogoLoop-style marquee -->
  <div class="loop-outer" id="loopOuter">
    <div class="loop-track" id="loopTrack">
      <!-- sequences injected by JS -->
    </div>
  </div>

  <!-- Posts Carousel -->
  <section class="tweets-section">
    <p class="tweets-title">Latest from X</p>
    <div class="posts-loop-outer" id="postsOuter">
      <div class="posts-loop-track" id="postsTrack">

          <a class="post-card" href="https://x.com/OG_Branxi/status/2022691127275716733" target="_blank" rel="noopener">
            <img src="assets/post_treadfi.png" alt="How to Optimize TreadFi MM Bot" draggable="false">
          </a>

          <a class="post-card" href="https://x.com/OG_Branxi/status/2027441892833824793" target="_blank" rel="noopener">
            <img src="assets/post_hotstuff.png" alt="Hotstuff retro points drop" draggable="false">
          </a>

          <a class="post-card" href="https://x.com/OG_Branxi/status/2026301178213281911" target="_blank" rel="noopener">
            <img src="assets/post_dreamcash.png" alt="Dreamcash XP and TreadFi points" draggable="false">
          </a>

          <a class="post-card" href="https://x.com/OG_Branxi/status/2025254149965971493" target="_blank" rel="noopener">
            <img src="assets/post_nado.png" alt="Nado points optimization" draggable="false">
          </a>

      </div>
    </div>
  </section>

  <footer>© 2026 Branxi</footer>
</div>

<script>
/* ═══════════════════════════════════════════════════════════════════════
   1. DEX DATA
═══════════════════════════════════════════════════════════════════════ */
const LOGOS = {};
LOGOS['treadfi']    = 'assets/logo_treadfi.png';
LOGOS['nado']       = 'assets/logo_nado.jpeg';
LOGOS['variational']= 'assets/logo_variational.png';
LOGOS['hotstuff']   = 'assets/logo_hotstuff.png';
LOGOS['01exchange'] = 'assets/logo_01exchange.jpeg';
LOGOS['extended']   = 'assets/logo_extended.png';
LOGOS['dreamcash']  = 'assets/logo_dreamcash.jpeg';
LOGOS['riseX']      = 'assets/logo_riseX.jpeg';

const DEX = [
  { name: 'TreadFi',    key: 'treadfi',    href: 'https://app.tread.fi/referral/7WG1VZXC' },
  { name: 'Nado',       key: 'nado',       href: 'https://app.nado.xyz?join=6HuO5CL' },
  { name: 'Variational',key: 'variational',href: 'https://omni.variational.io/?ref=OMNIVSZU495O' },
  { name: 'Hotstuff',   key: 'hotstuff',   href: 'https://app.hotstuff.trade/join/branxi' },
  { name: '01exchange', key: '01exchange', href: 'https://01.xyz/ref/branxi' },
  { name: 'Extended',   key: 'extended',   href: 'https://app.extended.exchange/join/BRANXI' },
  { name: 'Dreamcash',  key: 'dreamcash',  href: 'https://trade.dreamcash.xyz/trade?code=BRANXI' },
  { name: 'RiseX',      key: 'riseX',      href: null },   // coming soon
];

/* ═══════════════════════════════════════════════════════════════════════
   2. BUILD MARQUEE (LogoLoop approach: duplicate sequences until enough)
═══════════════════════════════════════════════════════════════════════ */
function buildCard(dex) {
  const el = dex.href
    ? document.createElement('a')
    : document.createElement('div');

  el.className = 'dex-card' + (dex.href ? '' : ' soon');
  if (dex.href) { el.href = dex.href; el.target = '_blank'; el.rel = 'noopener'; }

  const logo = LOGOS[dex.key];
  el.innerHTML = `
    ${logo ? `<img class="card-logo" src="${logo}" alt="${dex.name} logo" draggable="false">` : ''}
    <span class="card-name">${dex.name}</span>
    ${!dex.href ? `<span class="card-badge">Coming soon</span>` : ''}`;
  return el;
}

function buildSeq(isFirst) {
  const ul = document.createElement('div');
  ul.className = 'loop-seq';
  ul.setAttribute('aria-hidden', isFirst ? 'false' : 'true');
  DEX.forEach(d => ul.appendChild(buildCard(d)));
  return ul;
}

const track  = document.getElementById('loopTrack');
const outer  = document.getElementById('loopOuter');
const GAP_PX = 20; // must match --gap

// Build sequences until we have enough to fill the viewport + 2 extra
function ensureEnough() {
  const vw = outer.clientWidth;
  // measure first seq
  let firstSeq = track.querySelector('.loop-seq');
  if (!firstSeq) { firstSeq = buildSeq(true); track.appendChild(firstSeq); }

  const seqW = firstSeq.getBoundingClientRect().width;
  if (seqW === 0) return;

  const needed = Math.ceil(vw / seqW) + 2;
  const current = track.querySelectorAll('.loop-seq').length;
  for (let i = current; i < needed; i++) track.appendChild(buildSeq(false));
  return seqW;
}

let seqWidth = 0;
window.addEventListener('DOMContentLoaded', () => {
  seqWidth = ensureEnough() || 0;
});
window.addEventListener('resize', () => { seqWidth = ensureEnough() || seqWidth; });
// retry after fonts load
document.fonts.ready.then(() => { seqWidth = ensureEnough() || seqWidth; });

/* ═══════════════════════════════════════════════════════════════════════
   3. ANIMATION LOOP — faithful port of LogoLoop's useAnimationLoop
      SMOOTH_TAU = 0.25, direction = 'left', speed = 110 px/s
═══════════════════════════════════════════════════════════════════════ */
const SMOOTH_TAU    = 0.25;
const TARGET_SPEED  = 110;   // px/s rightward scroll
let   velocity      = 0;
let   offset        = 0;
let   lastTs        = null;
let   isHovered     = false;

outer.addEventListener('mouseenter', () => isHovered = true);
outer.addEventListener('mouseleave', () => isHovered = false);

function animate(ts) {
  if (lastTs === null) lastTs = ts;
  const dt = Math.max(0, ts - lastTs) / 1000;
  lastTs = ts;

  const target = isHovered ? 0 : TARGET_SPEED;
  const ease   = 1 - Math.exp(-dt / SMOOTH_TAU);
  velocity    += (target - velocity) * ease;

  if (seqWidth > 0) {
    offset = ((offset + velocity * dt) % seqWidth + seqWidth) % seqWidth;
    track.style.transform = `translate3d(${-offset}px, 0, 0)`;
  }

  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

/* ═══════════════════════════════════════════════════════════════════════
   4. DOT GRID BACKGROUND — faithful port of DotGrid.tsx
      dotSize=5, gap=15, baseColor="#271E37", activeColor="#5227FF"
      proximity=120, shockRadius=250, shockStrength=5
      resistance=750, returnDuration=1.5
      Physics: spring/damper replaces GSAP InertiaPlugin
═══════════════════════════════════════════════════════════════════════ */
(function () {
  const canvas = document.getElementById('bg-canvas');
  const ctx    = canvas.getContext('2d');
  if (!ctx) return;

  // ── Config (matches DotGrid usage props) ─────────────────────────────
  const DOT_SIZE       = 5;
  const GAP            = 15;
  const BASE_COLOR     = { r: 0x27, g: 0x1E, b: 0x37 };
  const ACTIVE_COLOR   = { r: 0x52, g: 0x27, b: 0xFF };
  const PROXIMITY      = 120;
  const PROX_SQ        = PROXIMITY * PROXIMITY;
  const SHOCK_RADIUS   = 250;
  const SHOCK_STRENGTH = 5;
  const RESISTANCE     = 750;   // px/s² deceleration
  const RETURN_DUR    = 1.5;    // s — elastic return
  const SPEED_TRIGGER  = 100;   // px/s to activate push
  const MAX_SPEED      = 5000;

  const DPR = Math.min(window.devicePixelRatio || 1, 2);

  // ── Dot state ─────────────────────────────────────────────────────────
  let dots = [];

  function buildGrid() {
    const W = window.innerWidth;
    const H = window.innerHeight;
    canvas.width        = W * DPR;
    canvas.height       = H * DPR;
    canvas.style.width  = W + 'px';
    canvas.style.height = H + 'px';
    ctx.scale(DPR, DPR);

    const cell = DOT_SIZE + GAP;
    const cols = Math.floor((W + GAP) / cell);
    const rows = Math.floor((H + GAP) / cell);
    const gridW = cell * cols - GAP;
    const gridH = cell * rows - GAP;
    const startX = (W - gridW) / 2 + DOT_SIZE / 2;
    const startY = (H - gridH) / 2 + DOT_SIZE / 2;

    dots = [];
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        dots.push({
          cx: startX + c * cell,
          cy: startY + r * cell,
          // current offset
          ox: 0, oy: 0,
          // velocity of offset
          vx: 0, vy: 0,
          // spring state: 'idle' | 'pushed' | 'returning'
          state: 'idle'
        });
      }
    }
  }

  window.addEventListener('resize', () => { buildGrid(); });
  buildGrid();

  // ── Pointer tracking ──────────────────────────────────────────────────
  const ptr = { x: -9999, y: -9999, vx: 0, vy: 0, speed: 0, lastX: 0, lastY: 0, lastT: 0 };

  let moveThrottle = 0;
  window.addEventListener('mousemove', e => {
    const now = performance.now();
    if (now - moveThrottle < 16) return;
    moveThrottle = now;

    const dt = ptr.lastT ? (now - ptr.lastT) / 1000 : 0.016;
    const dx = e.clientX - ptr.lastX;
    const dy = e.clientY - ptr.lastY;
    let vx = dx / dt, vy = dy / dt;
    let spd = Math.hypot(vx, vy);
    if (spd > MAX_SPEED) { const s = MAX_SPEED / spd; vx *= s; vy *= s; spd = MAX_SPEED; }

    ptr.lastX = e.clientX; ptr.lastY = e.clientY; ptr.lastT = now;
    ptr.vx = vx; ptr.vy = vy; ptr.speed = spd;
    ptr.x = e.clientX; ptr.y = e.clientY;

    // push nearby dots
    if (spd > SPEED_TRIGGER) {
      for (const d of dots) {
        if (d.state !== 'idle') continue;
        const dist = Math.hypot(d.cx - ptr.x, d.cy - ptr.y);
        if (dist < PROXIMITY) {
          d.state = 'pushed';
          // initial velocity burst toward push direction
          const pushX = (d.cx - ptr.x) + vx * 0.005;
          const pushY = (d.cy - ptr.y) + vy * 0.005;
          const mag = Math.hypot(pushX, pushY) || 1;
          d.vx = (pushX / mag) * spd * 0.12;
          d.vy = (pushY / mag) * spd * 0.12;
        }
      }
    }
  }, { passive: true });

  window.addEventListener('click', e => {
    for (const d of dots) {
      const dist = Math.hypot(d.cx - e.clientX, d.cy - e.clientY);
      if (dist < SHOCK_RADIUS) {
        d.state = 'pushed';
        const falloff = Math.max(0, 1 - dist / SHOCK_RADIUS);
        const pushX = (d.cx - e.clientX) * SHOCK_STRENGTH * falloff;
        const pushY = (d.cy - e.clientY) * SHOCK_STRENGTH * falloff;
        d.vx = pushX * 3;
        d.vy = pushY * 3;
      }
    }
  });

  // ── Physics step ──────────────────────────────────────────────────────
  // Simulates InertiaPlugin (deceleration) then elastic.out return.
  // Spring constants tuned to match returnDuration ≈ 1.5s with elastic feel.
  const SPRING_K   = 80;   // stiffness
  const SPRING_D   = 14;   // damping (critically damped ≈ 2√k → ~18, slightly under for bounce)
  const MAX_OFFSET = 60;   // clamp so dots don't fly off screen

  function stepDots(dt) {
    for (const d of dots) {
      if (d.state === 'idle') continue;

      if (d.state === 'pushed') {
        // Inertia: decelerate velocity
        const spd = Math.hypot(d.vx, d.vy);
        const decel = Math.min(RESISTANCE * dt, spd);
        if (spd > 0) {
          d.vx -= (d.vx / spd) * decel;
          d.vy -= (d.vy / spd) * decel;
        }
        d.ox += d.vx * dt;
        d.oy += d.vy * dt;
        // clamp
        d.ox = Math.max(-MAX_OFFSET, Math.min(MAX_OFFSET, d.ox));
        d.oy = Math.max(-MAX_OFFSET, Math.min(MAX_OFFSET, d.oy));

        if (Math.hypot(d.vx, d.vy) < 1) {
          d.state = 'returning';
          d.vx = 0; d.vy = 0;
        }
      } else if (d.state === 'returning') {
        // Spring toward (0,0) — elastic.out feel
        const fx = -SPRING_K * d.ox - SPRING_D * d.vx;
        const fy = -SPRING_K * d.oy - SPRING_D * d.vy;
        d.vx += fx * dt;
        d.vy += fy * dt;
        d.ox += d.vx * dt;
        d.oy += d.vy * dt;

        if (Math.hypot(d.ox, d.oy) < 0.1 && Math.hypot(d.vx, d.vy) < 0.1) {
          d.ox = 0; d.oy = 0; d.vx = 0; d.vy = 0;
          d.state = 'idle';
        }
      }
    }
  }

  // ── Draw ─────────────────────────────────────────────────────────────
  const circlePath = new Path2D();
  circlePath.arc(0, 0, DOT_SIZE / 2, 0, Math.PI * 2);

  function lerp(a, b, t) { return a + (b - a) * t; }

  function draw() {
    ctx.clearRect(0, 0, canvas.width / DPR, canvas.height / DPR);

    for (const d of dots) {
      const ox = d.cx + d.ox;
      const oy = d.cy + d.oy;
      const dx = d.cx - ptr.x;
      const dy = d.cy - ptr.y;
      const dsq = dx * dx + dy * dy;

      let r, g, b;
      if (dsq <= PROX_SQ) {
        const t = 1 - Math.sqrt(dsq) / PROXIMITY;
        r = Math.round(lerp(BASE_COLOR.r, ACTIVE_COLOR.r, t));
        g = Math.round(lerp(BASE_COLOR.g, ACTIVE_COLOR.g, t));
        b = Math.round(lerp(BASE_COLOR.b, ACTIVE_COLOR.b, t));
      } else {
        r = BASE_COLOR.r; g = BASE_COLOR.g; b = BASE_COLOR.b;
      }

      ctx.save();
      ctx.translate(ox, oy);
      ctx.fillStyle = `rgb(${r},${g},${b})`;
      ctx.fill(circlePath);
      ctx.restore();
    }
  }

  // ── Loop ─────────────────────────────────────────────────────────────
  let lastFrame = performance.now();
  function frame(now) {
    const dt = Math.min((now - lastFrame) / 1000, 0.05); // cap at 50ms
    lastFrame = now;
    stepDots(dt);
    draw();
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
})();

/* ═══════════════════════════════════════════════════════════════════════
   5. POSTS MARQUEE — same approach as DEX LogoLoop, speed 70 px/s
═══════════════════════════════════════════════════════════════════════ */
(function() {
  const track  = document.getElementById('postsTrack');
  const outer  = document.getElementById('postsOuter');
  if (!track || !outer) return;

  const POSTS_GAP     = 24;   // must match CSS gap
  const TARGET_SPEED  = 70;   // px/s
  const SMOOTH_TAU    = 0.25;

  // Collect original cards and duplicate until track fills viewport + 2x
  function buildSeq(isFirst) {
    const seq = document.createElement('div');
    seq.className = 'posts-seq';
    seq.style.cssText = 'display:flex;align-items:flex-start;gap:' + POSTS_GAP + 'px;padding-right:' + POSTS_GAP + 'px;flex-shrink:0;';
    seq.setAttribute('aria-hidden', isFirst ? 'false' : 'true');
    origCards.forEach(c => {
      const clone = c.cloneNode(true);
      seq.appendChild(clone);
    });
    return seq;
  }

  // Grab the original cards before we mess with the DOM
  const origCards = Array.from(track.querySelectorAll('.post-card'));
  // Clear track
  track.innerHTML = '';
  track.style.cssText = 'display:flex;align-items:flex-start;width:max-content;will-change:transform;user-select:none;padding:16px 0 24px;';

  function ensureEnough() {
    const vw = outer.clientWidth;
    let firstSeq = track.querySelector('.posts-seq');
    if (!firstSeq) { firstSeq = buildSeq(true); track.appendChild(firstSeq); }
    const seqW = firstSeq.getBoundingClientRect().width;
    if (seqW === 0) return 0;
    const needed = Math.ceil(vw / seqW) + 2;
    const current = track.querySelectorAll('.posts-seq').length;
    for (let i = current; i < needed; i++) track.appendChild(buildSeq(false));
    return seqW;
  }

  let seqWidth  = 0;
  let velocity  = 0;
  let offset    = 0;
  let lastTs    = null;
  let isHovered = false;

  outer.addEventListener('mouseenter', () => isHovered = true);
  outer.addEventListener('mouseleave', () => isHovered = false);

  window.addEventListener('DOMContentLoaded', () => { seqWidth = ensureEnough() || 0; });
  window.addEventListener('resize', () => { seqWidth = ensureEnough() || seqWidth; });
  document.fonts.ready.then(() => { seqWidth = ensureEnough() || seqWidth; });

  // Kick off immediately too
  seqWidth = ensureEnough() || 0;

  function animatePosts(ts) {
    if (lastTs === null) lastTs = ts;
    const dt = Math.max(0, ts - lastTs) / 1000;
    lastTs = ts;

    const target = isHovered ? 0 : TARGET_SPEED;
    const ease   = 1 - Math.exp(-dt / SMOOTH_TAU);
    velocity    += (target - velocity) * ease;

    if (seqWidth > 0) {
      offset = ((offset + velocity * dt) % seqWidth + seqWidth) % seqWidth;
      track.style.transform = 'translate3d(' + (-offset) + 'px, 0, 0)';
    }
    requestAnimationFrame(animatePosts);
  }
  requestAnimationFrame(animatePosts);
})();

</script>

</body>
</html>
